"""
Event system for Nightwatch.

Provides standardized event format, serialization, and ZeroMQ-based pub/sub
for inter-process communication between detectors and the alert engine.
"""

from __future__ import annotations

import asyncio
import time
import uuid
from collections import deque
from dataclasses import dataclass, field, asdict
from enum import Enum
from typing import Any, Callable, Awaitable, Optional

import msgpack
import zmq
import zmq.asyncio


class EventState(str, Enum):
    """State reported by a detector."""

    NORMAL = "normal"
    WARNING = "warning"
    ALERT = "alert"
    UNCERTAIN = "uncertain"
    OFFLINE = "offline"


class EventSeverity(str, Enum):
    """Severity level for alerts."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass(frozen=True, slots=True)
class Event:
    """
    Immutable event emitted by detectors.

    All detectors emit events in this standardized format, enabling
    the alert engine to process signals uniformly regardless of source.
    """

    detector: str  # Source detector ID (e.g., "radar", "audio", "bcg")
    timestamp: float  # Unix timestamp (time.time())
    confidence: float  # Detection confidence 0.0 - 1.0
    state: EventState  # Current detector state
    value: dict[str, Any]  # Detector-specific data
    sequence: int = 0  # Monotonic sequence number for ordering
    session_id: str = ""  # Monitoring session identifier

    def __post_init__(self) -> None:
        """Validate event data."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be 0.0-1.0, got {self.confidence}")
        if not self.detector:
            raise ValueError("Detector name cannot be empty")

    def to_bytes(self) -> bytes:
        """Serialize event to msgpack bytes for ZeroMQ transmission."""
        data = {
            "detector": self.detector,
            "timestamp": self.timestamp,
            "confidence": self.confidence,
            "state": self.state.value,
            "value": self.value,
            "sequence": self.sequence,
            "session_id": self.session_id,
        }
        return msgpack.packb(data, use_bin_type=True)

    @classmethod
    def from_bytes(cls, data: bytes) -> Event:
        """Deserialize event from msgpack bytes."""
        unpacked = msgpack.unpackb(data, raw=False)
        return cls(
            detector=unpacked["detector"],
            timestamp=unpacked["timestamp"],
            confidence=unpacked["confidence"],
            state=EventState(unpacked["state"]),
            value=unpacked["value"],
            sequence=unpacked.get("sequence", 0),
            session_id=unpacked.get("session_id", ""),
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "detector": self.detector,
            "timestamp": self.timestamp,
            "confidence": self.confidence,
            "state": self.state.value,
            "value": self.value,
            "sequence": self.sequence,
            "session_id": self.session_id,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Event:
        """Create event from dictionary."""
        return cls(
            detector=data["detector"],
            timestamp=data["timestamp"],
            confidence=data["confidence"],
            state=EventState(data["state"]),
            value=data["value"],
            sequence=data.get("sequence", 0),
            session_id=data.get("session_id", ""),
        )


@dataclass(frozen=True, slots=True)
class Alert:
    """
    Alert generated by the alert engine.

    Alerts are triggered when detector events match configured rules.
    They have lifecycle states (active, acknowledged, resolved) and
    can be sent to multiple notification channels.
    """

    id: str  # Unique alert ID (UUID)
    timestamp: float  # When alert was triggered
    severity: EventSeverity  # Alert severity level
    rule_name: str  # Which rule triggered this alert
    message: str  # Human-readable message
    contributing_events: tuple[Event, ...] = field(default_factory=tuple)
    acknowledged: bool = False
    resolved: bool = False
    acknowledged_at: Optional[float] = None
    resolved_at: Optional[float] = None

    @classmethod
    def create(
        cls,
        severity: EventSeverity,
        rule_name: str,
        message: str,
        contributing_events: list[Event] | None = None,
    ) -> Alert:
        """Create a new alert with auto-generated ID and timestamp."""
        return cls(
            id=str(uuid.uuid4()),
            timestamp=time.time(),
            severity=severity,
            rule_name=rule_name,
            message=message,
            contributing_events=tuple(contributing_events or []),
        )

    def to_bytes(self) -> bytes:
        """Serialize alert to msgpack bytes."""
        data = {
            "id": self.id,
            "timestamp": self.timestamp,
            "severity": self.severity.value,
            "rule_name": self.rule_name,
            "message": self.message,
            "contributing_events": [e.to_dict() for e in self.contributing_events],
            "acknowledged": self.acknowledged,
            "resolved": self.resolved,
            "acknowledged_at": self.acknowledged_at,
            "resolved_at": self.resolved_at,
        }
        return msgpack.packb(data, use_bin_type=True)

    @classmethod
    def from_bytes(cls, data: bytes) -> Alert:
        """Deserialize alert from msgpack bytes."""
        unpacked = msgpack.unpackb(data, raw=False)
        return cls(
            id=unpacked["id"],
            timestamp=unpacked["timestamp"],
            severity=EventSeverity(unpacked["severity"]),
            rule_name=unpacked["rule_name"],
            message=unpacked["message"],
            contributing_events=tuple(
                Event.from_dict(e) for e in unpacked.get("contributing_events", [])
            ),
            acknowledged=unpacked.get("acknowledged", False),
            resolved=unpacked.get("resolved", False),
            acknowledged_at=unpacked.get("acknowledged_at"),
            resolved_at=unpacked.get("resolved_at"),
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "id": self.id,
            "timestamp": self.timestamp,
            "severity": self.severity.value,
            "rule_name": self.rule_name,
            "message": self.message,
            "contributing_events": [e.to_dict() for e in self.contributing_events],
            "acknowledged": self.acknowledged,
            "resolved": self.resolved,
            "acknowledged_at": self.acknowledged_at,
            "resolved_at": self.resolved_at,
        }

    def acknowledge(self) -> Alert:
        """Return a new alert marked as acknowledged."""
        return Alert(
            id=self.id,
            timestamp=self.timestamp,
            severity=self.severity,
            rule_name=self.rule_name,
            message=self.message,
            contributing_events=self.contributing_events,
            acknowledged=True,
            resolved=self.resolved,
            acknowledged_at=time.time(),
            resolved_at=self.resolved_at,
        )

    def resolve(self) -> Alert:
        """Return a new alert marked as resolved."""
        return Alert(
            id=self.id,
            timestamp=self.timestamp,
            severity=self.severity,
            rule_name=self.rule_name,
            message=self.message,
            contributing_events=self.contributing_events,
            acknowledged=self.acknowledged,
            resolved=True,
            acknowledged_at=self.acknowledged_at,
            resolved_at=time.time(),
        )


class Publisher:
    """ZeroMQ PUB socket wrapper for detectors to emit events."""

    def __init__(self, context: zmq.asyncio.Context, endpoint: str):
        self._socket = context.socket(zmq.PUB)
        self._socket.bind(endpoint)
        self._endpoint = endpoint

    async def send(self, event: Event) -> None:
        """Send event with topic prefix based on detector name."""
        topic = event.detector.encode("utf-8")
        await self._socket.send_multipart([topic, event.to_bytes()])

    async def send_alert(self, alert: Alert) -> None:
        """Send alert with 'alert' topic."""
        topic = b"alert"
        await self._socket.send_multipart([topic, alert.to_bytes()])

    def close(self) -> None:
        """Close the socket."""
        self._socket.close()


class Subscriber:
    """ZeroMQ SUB socket wrapper for consuming events."""

    def __init__(
        self,
        context: zmq.asyncio.Context,
        endpoint: str,
        topics: list[str] | None = None,
    ):
        self._socket = context.socket(zmq.SUB)
        self._socket.connect(endpoint)
        self._endpoint = endpoint
        self._callback: Callable[[str, Event], Awaitable[None]] | None = None
        self._alert_callback: Callable[[Alert], Awaitable[None]] | None = None
        self._running = False

        # Subscribe to topics
        if topics:
            for topic in topics:
                self._socket.setsockopt(zmq.SUBSCRIBE, topic.encode("utf-8"))
        else:
            # Subscribe to all topics
            self._socket.setsockopt(zmq.SUBSCRIBE, b"")

    async def receive(self) -> tuple[str, Event | Alert]:
        """Receive next message, returns (topic, event/alert)."""
        topic_bytes, data = await self._socket.recv_multipart()
        topic = topic_bytes.decode("utf-8")

        if topic == "alert":
            return topic, Alert.from_bytes(data)
        else:
            return topic, Event.from_bytes(data)

    def set_callback(
        self,
        callback: Callable[[str, Event], Awaitable[None]],
        alert_callback: Callable[[Alert], Awaitable[None]] | None = None,
    ) -> None:
        """Set async callback for received events."""
        self._callback = callback
        self._alert_callback = alert_callback

    async def run(self) -> None:
        """Run receive loop with callback."""
        if not self._callback:
            raise RuntimeError("No callback set")

        self._running = True
        while self._running:
            try:
                topic, message = await self.receive()
                if isinstance(message, Alert) and self._alert_callback:
                    await self._alert_callback(message)
                elif isinstance(message, Event):
                    await self._callback(topic, message)
            except zmq.ZMQError as e:
                if self._running:
                    raise e
                break

    def stop(self) -> None:
        """Stop the receive loop."""
        self._running = False

    def close(self) -> None:
        """Close the socket."""
        self._running = False
        self._socket.close()


class EventBus:
    """
    ZeroMQ-based pub/sub event bus for Nightwatch.

    Provides centralized event routing between detectors and consumers.
    Uses IPC sockets for low-latency local communication.
    """

    DEFAULT_EVENT_ENDPOINT = "ipc:///tmp/nightwatch-events"
    DEFAULT_ALERT_ENDPOINT = "ipc:///tmp/nightwatch-alerts"

    def __init__(
        self,
        event_endpoint: str | None = None,
        alert_endpoint: str | None = None,
        context: zmq.asyncio.Context | None = None,
    ):
        self._context = context or zmq.asyncio.Context()
        self._owns_context = context is None
        self._event_endpoint = event_endpoint or self.DEFAULT_EVENT_ENDPOINT
        self._alert_endpoint = alert_endpoint or self.DEFAULT_ALERT_ENDPOINT
        self._publishers: list[Publisher] = []
        self._subscribers: list[Subscriber] = []

    def create_publisher(self, endpoint: str | None = None) -> Publisher:
        """Create a publisher socket bound to the given endpoint."""
        pub = Publisher(self._context, endpoint or self._event_endpoint)
        self._publishers.append(pub)
        return pub

    def create_subscriber(
        self,
        topics: list[str] | None = None,
        endpoint: str | None = None,
    ) -> Subscriber:
        """Create a subscriber socket connected to the given endpoint."""
        sub = Subscriber(self._context, endpoint or self._event_endpoint, topics)
        self._subscribers.append(sub)
        return sub

    def create_alert_publisher(self) -> Publisher:
        """Create a publisher for alerts."""
        pub = Publisher(self._context, self._alert_endpoint)
        self._publishers.append(pub)
        return pub

    def create_alert_subscriber(self) -> Subscriber:
        """Create a subscriber for alerts."""
        sub = Subscriber(self._context, self._alert_endpoint, ["alert"])
        self._subscribers.append(sub)
        return sub

    async def close(self) -> None:
        """Close all sockets and optionally the context."""
        for pub in self._publishers:
            pub.close()
        for sub in self._subscribers:
            sub.close()
        self._publishers.clear()
        self._subscribers.clear()

        if self._owns_context:
            self._context.term()


class EventBuffer:
    """Thread-safe ring buffer for recent events."""

    def __init__(self, capacity: int = 1000):
        self._buffer: deque[Event] = deque(maxlen=capacity)
        self._by_detector: dict[str, deque[Event]] = {}
        self._capacity = capacity

    def append(self, event: Event) -> None:
        """Add event to buffer."""
        self._buffer.append(event)

        if event.detector not in self._by_detector:
            self._by_detector[event.detector] = deque(maxlen=self._capacity // 4)
        self._by_detector[event.detector].append(event)

    def get_recent(self, seconds: float) -> list[Event]:
        """Get events from the last N seconds."""
        cutoff = time.time() - seconds
        return [e for e in self._buffer if e.timestamp >= cutoff]

    def get_by_detector(self, detector: str, count: int | None = None) -> list[Event]:
        """Get recent events from a specific detector."""
        if detector not in self._by_detector:
            return []

        events = list(self._by_detector[detector])
        if count is not None:
            events = events[-count:]
        return events

    def get_latest(self, detector: str) -> Event | None:
        """Get the most recent event from a detector."""
        events = self._by_detector.get(detector)
        if events:
            return events[-1]
        return None

    def get_all_latest(self) -> dict[str, Event]:
        """Get the most recent event from each detector."""
        return {
            detector: events[-1]
            for detector, events in self._by_detector.items()
            if events
        }

    def clear(self) -> None:
        """Clear all events."""
        self._buffer.clear()
        self._by_detector.clear()

    def __len__(self) -> int:
        return len(self._buffer)
